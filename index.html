<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>宇宙風パイプ（敵は画面左半分に入らない）</title>
<style>
  html,body { height:100%; margin:0; background:#021022; -webkit-tap-highlight-color: transparent; }
  canvas#game {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    background: linear-gradient(#071428,#0b2a44);
    transition: filter 0.12s linear;
  }
  .overlay { position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
  #score { position:absolute; left:12px; top:12px; z-index:30; font-size:20px; color:#fff; text-shadow:0 2px 6px rgba(0,0,0,0.6); pointer-events:auto; background: rgba(255,255,255,0.06); padding:6px 10px; border-radius:8px; }
  .center { position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); text-align:center; z-index:30; pointer-events:auto; }
  #message { font-size:18px; color:#fff; text-shadow:0 2px 4px rgba(0,0,0,0.5); background: rgba(0,0,0,0.18); display:inline-block; padding:8px 12px; border-radius:8px; white-space:pre-line; }
  #gameOverPanel { position: absolute; left: 50%; top: 36%; transform: translate(-50%, -50%); z-index: 40; pointer-events: none; text-align: center; color: #fff; display: none; }
  #finalScore { font-size: 48px; font-weight: 700; color: #ffd86b; text-shadow: 0 6px 18px rgba(0,0,0,0.6); margin-bottom: 8px; }
  #finalEval { font-size: 22px; color: #bfefff; margin-bottom: 6px; }
  #musicCredit { font-size: 14px; color: rgba(255,255,255,0.85); margin-top: 6px; }
  #retryHint { font-size: 14px; color: rgba(255,255,255,0.85); margin-top:6px; }
  @media (max-width:420px){
    #message{ font-size:16px; padding:6px 10px; }
    #finalScore{ font-size:36px; }
    #finalEval{ font-size:18px; }
    #musicCredit{ font-size:13px; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="overlay" aria-hidden="false">
  <div id="score">Score: 0</div>
  <div class="center" id="centerMessage"><div id="message">タップしてスタート</div></div>
</div>

<div id="gameOverPanel" aria-hidden="true">
  <div id="finalScore">0</div>
  <div id="finalEval">評価</div>
  <div id="musicCredit">music: ConteDeFees, FC音工場</div>
  <div id="retryHint">1秒後にタップで再開できます</div>
</div>

<script>
(() => {
  // --- 音声ファイルをすべて mp3 に変更しました ---
  const JUMP_SOUND_SRC = 'assets/jump.mp3';
  const BGM_SRC = 'assets/bgm.mp3';
  const HIT_SOUND_SRC = 'assets/hit.mp3';
  const EXPLODE_SOUND_SRC = 'assets/explode.mp3';
  const GAMEOVER_BGM_SRC = 'assets/gameover.mp3';

  // --- DOM ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const gameOverPanel = document.getElementById('gameOverPanel');
  const finalScoreEl = document.getElementById('finalScore');
  const finalEvalEl = document.getElementById('finalEval');
  const musicCreditEl = document.getElementById('musicCredit');

  // --- Audio (HTMLAudio + optional AudioContext) ---
  let htmlJumpAudio = null, htmlBgmAudio = null, htmlHitAudio = null, htmlExplodeAudio = null, htmlGameoverAudio = null;
  let audioInitialized = false;
  let audioCtx = null, jumpBuffer = null, hitBuffer = null, explodeBuffer = null, gameoverBuffer = null;
  let gameoverSource = null;

  async function initAudioIfNeeded() {
    if (audioInitialized) return;
    try { htmlJumpAudio = new Audio(JUMP_SOUND_SRC); htmlJumpAudio.preload = 'auto'; } catch(e){ htmlJumpAudio = null; }
    try { htmlBgmAudio = new Audio(BGM_SRC); htmlBgmAudio.preload = 'auto'; htmlBgmAudio.loop = true; htmlBgmAudio.volume = 0.45; } catch(e){ htmlBgmAudio = null; }
    try { htmlHitAudio = new Audio(HIT_SOUND_SRC); htmlHitAudio.preload = 'auto'; } catch(e){ htmlHitAudio = null; }
    try { htmlExplodeAudio = new Audio(EXPLODE_SOUND_SRC); htmlExplodeAudio.preload = 'auto'; } catch(e){ htmlExplodeAudio = null; }
    try { htmlGameoverAudio = new Audio(GAMEOVER_BGM_SRC); htmlGameoverAudio.preload = 'auto'; htmlGameoverAudio.loop = false; htmlGameoverAudio.volume = 0.7; } catch(e){ htmlGameoverAudio = null; }

    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) {
        audioCtx = new Ctx();
        const jResp = await fetch(JUMP_SOUND_SRC).catch(()=>null);
        if (jResp && jResp.ok) { const ab = await jResp.arrayBuffer().catch(()=>null); if (ab) jumpBuffer = await audioCtx.decodeAudioData(ab).catch(()=>null); }
        const hResp = await fetch(HIT_SOUND_SRC).catch(()=>null);
        if (hResp && hResp.ok) { const ab2 = await hResp.arrayBuffer().catch(()=>null); if (ab2) hitBuffer = await audioCtx.decodeAudioData(ab2).catch(()=>null); }
        const eResp = await fetch(EXPLODE_SOUND_SRC).catch(()=>null);
        if (eResp && eResp.ok) { const ab3 = await eResp.arrayBuffer().catch(()=>null); if (ab3) explodeBuffer = await audioCtx.decodeAudioData(ab3).catch(()=>null); }
        const gResp = await fetch(GAMEOVER_BGM_SRC).catch(()=>null);
        if (gResp && gResp.ok) { const ab4 = await gResp.arrayBuffer().catch(()=>null); if (ab4) gameoverBuffer = await audioCtx.decodeAudioData(ab4).catch(()=>null); }
      }
    } catch(e) {
      audioCtx = null; jumpBuffer = null; hitBuffer = null; explodeBuffer = null; gameoverBuffer = null;
    }
    audioInitialized = true;
  }

  function playBuffer(buffer, vol=1.0) {
    try {
      if (audioCtx && buffer) {
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const g = audioCtx.createGain();
        g.gain.value = vol;
        src.connect(g);
        g.connect(audioCtx.destination);
        src.start(0);
        return src;
      }
    } catch(e){}
    return null;
  }
  function playJumpSound(){ if (playBuffer(jumpBuffer,0.9)) return; if (htmlJumpAudio){ const a=htmlJumpAudio.cloneNode(true); a.volume=0.9; a.play().catch(()=>{}); } }
  function playHitSound(){ if (playBuffer(hitBuffer,1.0)) return; if (htmlHitAudio){ const a=htmlHitAudio.cloneNode(true); a.volume=1.0; a.play().catch(()=>{}); } }
  function playExplodeSound(){ if (playBuffer(explodeBuffer,1.0)) return; if (htmlExplodeAudio){ const a=htmlExplodeAudio.cloneNode(true); a.volume=1.0; a.play().catch(()=>{}); } }

  function playGameoverBgm() {
    try {
      stopGameoverBgm();
      if (audioCtx && gameoverBuffer) {
        const src = audioCtx.createBufferSource();
        src.buffer = gameoverBuffer;
        const g = audioCtx.createGain();
        g.gain.value = 0.9;
        src.connect(g);
        g.connect(audioCtx.destination);
        src.start(0);
        gameoverSource = src;
        src.onended = () => { if (gameoverSource === src) gameoverSource = null; };
        return;
      }
      if (htmlGameoverAudio) { htmlGameoverAudio.pause(); try { htmlGameoverAudio.currentTime = 0; } catch(e){}; htmlGameoverAudio.play().catch(()=>{}); }
    } catch (e) {}
  }

  function stopGameoverBgm() {
    try {
      if (gameoverSource) {
        try { gameoverSource.stop(); } catch(e) {}
        gameoverSource = null;
      }
    } catch(e){}
    try {
      if (htmlGameoverAudio && !htmlGameoverAudio.paused) {
        htmlGameoverAudio.pause();
        try { htmlGameoverAudio.currentTime = 0; } catch(e){}
      }
    } catch(e){}
  }

  function playBgm() {
    try {
      if (!htmlBgmAudio) return;
      htmlBgmAudio.pause();
      try { htmlBgmAudio.currentTime = 0; } catch(e) {}
      htmlBgmAudio.play().catch(()=>{});
    } catch (e) {}
  }
  function pauseBgm() {
    try {
      if (!htmlBgmAudio) return;
      if (!htmlBgmAudio.paused) htmlBgmAudio.pause();
      try { htmlBgmAudio.currentTime = 0; } catch(e) {}
    } catch (e) {}
  }

  // --- resize ---
  function resize(){ const ratio = window.devicePixelRatio || 1; const w = Math.max(window.innerWidth,320); const h = Math.max(window.innerHeight,320); canvas.style.width = w + 'px'; canvas.style.height = h + 'px'; canvas.width = Math.floor(w * ratio); canvas.height = Math.floor(h * ratio); ctx.setTransform(ratio,0,0,ratio,0,0); ctx.imageSmoothingEnabled = true; }
  window.addEventListener('resize', resize);
  resize();

  // --- game constants & state ---
  const INITIAL_GAP = 300;
  // パイプの最小縦間隔を約1.5倍に拡張（140 -> 210）
  const MIN_GAP = 210;
  const SCORE_RAMP_MAX = 100;
  const RAMP_DURATION_MS = 30000;
  const INITIAL_INTERVAL_MAX = 2600;
  const MIN_INTERVAL = 1800;
  const INTERVAL_RAMP_MS = 30000;
  const GRAVITY = 0.6;
  const THRUST = -10;
  const PIPE_WIDTH = 52;
  const PIPE_STRIPES = 3;
  const SPARK_CHANCE = 0.006;
  const COLOR_HUES = [200,160,280,40,10,120,260,340,30,195];

  const PIPE_SPEED_BASE_PPS = 120;
  const PIPE_SPEED_MAX_PPS = 220;
  const PLAYER_BULLET_SPEED_PPS = 520;
  // 敵の基本最大速度を上げる（60 -> 90）
  const ENEMY_BASE_MAX_VX_PPS = 90;
  const ENEMY_MAX_EXTRA_PER_SCORE = 1.6;
  const ENEMY_HP_CAP = 10;

  const ENEMY_FIRE_BASE_MIN = 900;
  const ENEMY_FIRE_RANDOM = 400;

  let ship = { x: 80, y: 150, vy: 0, r: 22, angle: 0, thrusting: false };
  let pipes = [];
  let lastPipeTime = 0;
  let nextPipeDelay = INITIAL_INTERVAL_MAX;
  let score = 0;
  let running = false;
  let gameOver = false;
  let lastTime = 0;
  let startTime = null;
  let ignoreInputUntil = 0;

  let enemyActive = false;
  let enemy = null;
  let lastEnemySpawnScore = -9999;
  const ENEMY_SPAWN_SCORE_GAP = 10;

  const playerBullets = [];
  const enemyBullets = [];

  const starLayers = [
    {count:80, speed:0.02, sizeRange:[0.6,1.6], color:'#e8f8ff', offset:Math.random()*1000},
    {count:40, speed:0.06, sizeRange:[1.2,2.6], color:'#cfefff', offset:Math.random()*1000},
    {count:18, speed:0.12, sizeRange:[1.8,3.6], color:'#ffffff', offset:Math.random()*1000}
  ];
  const stars = [];
  for (let li=0; li<starLayers.length; li++){
    const layer = starLayers[li];
    for (let i=0;i<layer.count;i++){
      stars.push({ layer:li, x:Math.random(), y:Math.random(), size: layer.sizeRange[0] + Math.random()*(layer.sizeRange[1]-layer.sizeRange[0]), tw: Math.random()*1000 });
    }
  }
  const nebulaLayers = [
    {colorA:'#0b2a44', colorB:'#1b4a66', alpha:0.12, speed:0.02, scale:1.6, offset:Math.random()*1000},
    {colorA:'#122b3f', colorB:'#0f3a5a', alpha:0.08, speed:0.035, scale:1.1, offset:Math.random()*1000},
    {colorA:'#0f2b44', colorB:'#072a3a', alpha:0.06, speed:0.06, scale:0.8, offset:Math.random()*1000}
  ];
  const meteors = [];
  for (let i=0;i<12;i++){
    meteors.push({ x:Math.random(), y:Math.random(), vx:-0.002 - Math.random()*0.006, vy:0.001 + Math.random()*0.003, life:Math.random()*4000, t:Math.random()*6000, size:1 + Math.random()*2 });
  }
  function createNoiseCanvas(w,h,alpha){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); const img=g.createImageData(w,h); for (let i=0;i<img.data.length;i+=4){ const v=200+Math.floor(Math.random()*55); img.data[i]=v; img.data[i+1]=v; img.data[i+2]=v; img.data[i+3]=Math.floor(255*alpha*Math.random()); } g.putImageData(img,0,0); return c; }
  const noise = createNoiseCanvas(128,128,0.04);

  function difficultyFactor(){ if(!startTime) return 0; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/RAMP_DURATION_MS); return t*t; }
  function currentIntervalMax(){ if(!startTime) return INITIAL_INTERVAL_MAX; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/INTERVAL_RAMP_MS); const f=t*t; return Math.round(INITIAL_INTERVAL_MAX + (MIN_INTERVAL - INITIAL_INTERVAL_MAX)*f); }
  function currentPipeSpeedPPS(){ const f=difficultyFactor(); return PIPE_SPEED_BASE_PPS + (PIPE_SPEED_MAX_PPS - PIPE_SPEED_BASE_PPS) * f; }
  function gapAtSpawn() { const sf = Math.min(1, score / SCORE_RAMP_MAX); return Math.round(INITIAL_GAP + (MIN_GAP - INITIAL_GAP) * sf); }
  function circleRectIntersect(cx, cy, r, rx, ry, rw, rh){ const nearestX = Math.max(rx, Math.min(cx, rx + rw)); const nearestY = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - nearestX; const dy = cy - nearestY; return (dx*dx + dy*dy) < (r*r); }
  function hslToRgb(h,s,l){ s/=100; l/=100; const k = n => (n + h/30) % 12; const a = s * Math.min(l,1-l); const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); return [Math.round(255*f(0)), Math.round(255*f(8)), Math.round(255*f(4))]; }

  let sepiaAnim = null;
  function applySepiaTransition(duration_ms = 800) {
    const el = canvas;
    if (!el) return;
    if (sepiaAnim) { cancelAnimationFrame(sepiaAnim.raf); sepiaAnim = null; }
    const start = performance.now();
    const from = 0, to = 1;
    sepiaAnim = { raf: null };
    function step(now) {
      const t = Math.min(1, (now - start) / duration_ms);
      const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      const sep = from + (to - from) * ease;
      el.style.filter = `sepia(${sep}) saturate(${0.6 + 0.4*(1-sep)}) contrast(${0.95})`;
      if (t < 1) sepiaAnim.raf = requestAnimationFrame(step);
      else sepiaAnim = null;
    }
    sepiaAnim.raf = requestAnimationFrame(step);
  }
  function clearSepiaTransition(duration_ms = 200) {
    const el = canvas;
    if (!el) return;
    if (sepiaAnim) { cancelAnimationFrame(sepiaAnim.raf); sepiaAnim = null; }
    if (duration_ms <= 0) { el.style.filter = 'none'; return; }
    const start = performance.now();
    const initial = 1;
    function step(now) {
      const t = Math.min(1, (now - start) / duration_ms);
      const ease = 1 - t;
      const sep = initial * ease;
      el.style.filter = `sepia(${sep}) saturate(${0.6 + 0.4*(1-sep)}) contrast(${0.95})`;
      if (t < 1) requestAnimationFrame(step);
      else el.style.filter = 'none';
    }
    requestAnimationFrame(step);
  }

  function onPointerDown(e){
    if (e.cancelable) e.preventDefault();
    initAudioIfNeeded().then(()=>{ if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); }).catch(()=>{});
    if (performance.now() < ignoreInputUntil) return;
    if (gameOver){ reset(); start(); return; }
    if (!running){ start(); return; }

    ship.vy = THRUST;
    ship.thrusting = true;
    ship.angle = -0.5;

    playJumpSound();

    const enemyPresent = (typeof enemy !== 'undefined' && enemy !== null) || enemyActive;
    if (enemyPresent) {
      const bx = ship.x + ship.r * 0.9;
      const by = ship.y - ship.r*0.08;
      playerBullets.push({ x: bx, y: by, vx: PLAYER_BULLET_SPEED_PPS, vy: 0, r: 5 });
    }
  }
  function onPointerUp(e){ if (e.cancelable) e.preventDefault(); ship.thrusting = false; }
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointerup', onPointerUp, {passive:false});
  canvas.addEventListener('pointercancel', onPointerUp, {passive:false});
  document.body.addEventListener('pointerdown', onPointerDown, {passive:false});
  document.body.addEventListener('pointerup', onPointerUp, {passive:false});

  function spawnPipe(){
    const ch = canvas.clientHeight;
    const gap = gapAtSpawn();
    const minTop = 40;
    const maxTop = ch - gap - 40;
    const top = Math.floor(Math.random() * Math.max(1, (maxTop - minTop + 1))) + minTop;
    const bucket = Math.floor(score / 10);
    const hue = COLOR_HUES[bucket % COLOR_HUES.length];

    const minPixelSpacing = Math.max(260, PIPE_WIDTH * 2);
    if (pipes.length > 0) {
      const last = pipes[pipes.length - 1];
      if (last.x > canvas.clientWidth - minPixelSpacing) {
        lastPipeTime = performance.now();
        nextPipeDelay = Math.max(nextPipeDelay, currentIntervalMax());
        return;
      }
    }

    pipes.push({ x: canvas.clientWidth + 10, top: top, gap: gap, hue: hue, passed: false, sparkleTimer: 0 });
    const intervalMax = currentIntervalMax();
    const range = Math.max(0, intervalMax - MIN_INTERVAL);
    nextPipeDelay = Math.max(MIN_INTERVAL + Math.floor(Math.random() * (range + 1)), 1200);
    lastPipeTime = performance.now();
  }

  // --- spawn enemy: 出現時に即撃ち開始するように変更 ---
  function spawnEnemyUFO() {
    enemyActive = true;
    const hp = Math.min(ENEMY_HP_CAP, Math.max(1, Math.floor(score / 5) + 1));
    const h = canvas.clientHeight;
    const startY = Math.floor(h * (0.15 + Math.random() * 0.5));
    enemy = {
      x: canvas.clientWidth + 80,
      y: startY,
      vx: -120,
      vy: 0,
      r: 34,
      hp: hp,
      fireTimer: 0,
      fireInterval: ENEMY_FIRE_BASE_MIN + Math.floor(Math.random()*ENEMY_FIRE_RANDOM),
      patternPhase: Math.floor(Math.random()*3),
      entryDone: false,
      hue: Math.floor(Math.random()*360),
      // patrolLeft を画面中央（左半分の境界）より右に設定して、敵が左半分に入らないようにする
      patrolLeft: Math.floor(Math.max(canvas.clientWidth * 0.5, canvas.clientWidth * 0.18)),
      patrolRight: Math.floor(canvas.clientWidth * 0.92),
      targetX: null,
      wobblePhase: Math.random()*Math.PI*2,
      wobbleAmp: 14 + Math.random()*12,
      wobbleSpeed: 0.8 + Math.random()*0.8,
      lastManeuver: performance.now(),
      maneuverInterval: 800 + Math.random()*1200,
      dodgeCooldown: 0
    };
    // targetX を patrol 範囲内に設定（必ず左半分より右）
    enemy.targetX = enemy.patrolLeft + Math.random() * Math.max(1, (enemy.patrolRight - enemy.patrolLeft));
    lastEnemySpawnScore = score;
    lastPipeTime = performance.now();

    try {
      fireEnemyPattern(enemy.patternPhase);
    } catch (e) {}
    enemy.fireTimer = 0;
    enemy.fireInterval = ENEMY_FIRE_BASE_MIN + Math.floor(Math.random()*ENEMY_FIRE_RANDOM);
  }

  function updateEnemy(dtMs) {
    if (!enemy) return;
    const dt = dtMs / 1000;
    const now = performance.now();
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    if (!enemy.entryDone) {
      enemy.x += enemy.vx * dt;
      const targetEntryX = Math.floor(w * 0.68);
      if (enemy.x <= targetEntryX) {
        enemy.x = targetEntryX;
        enemy.entryDone = true;
        enemy.vx = 0;
        enemy.fireTimer = 0;
        // 再設定: patrolLeft を必ず画面中央より右に
        enemy.patrolLeft = Math.floor(Math.max(w * 0.5, w * 0.18));
        enemy.patrolRight = Math.floor(w * 0.92);
        enemy.targetX = enemy.patrolLeft + Math.random() * Math.max(1, (enemy.patrolRight - enemy.patrolLeft));
        enemy.lastManeuver = now;
      }
      // entry 中はそのまま（spawn 時に即撃ち済み）
    }

    const scoreFactor = Math.min(1.5, score * 0.02);
    const speedMultiplier = 1 + scoreFactor;

    enemy.wobblePhase += enemy.wobbleSpeed * dt;
    const wobbleOffset = Math.sin(enemy.wobblePhase) * enemy.wobbleAmp;

    if (enemy.targetX === null) enemy.targetX = enemy.patrolLeft + Math.random() * Math.max(1, (enemy.patrolRight - enemy.patrolLeft));
    const dx = enemy.targetX - enemy.x;
    const desiredVx = Math.sign(dx) * (60 + 60 * speedMultiplier);
    const accel = 120;
    if (enemy.vx < desiredVx) enemy.vx = Math.min(desiredVx, enemy.vx + accel * dt);
    else enemy.vx = Math.max(desiredVx, enemy.vx - accel * dt);

    const maxVx = ENEMY_BASE_MAX_VX_PPS * (1 + Math.min(ENEMY_MAX_EXTRA_PER_SCORE, score * 0.02));
    enemy.vx = Math.max(-maxVx, Math.min(maxVx, enemy.vx));

    enemy.x += enemy.vx * dt;

    // --- 重要: 敵が画面の左半分に入らないように常に制限 ---
    const leftLimit = Math.floor(w * 0.5);
    if (enemy.x < leftLimit) {
      enemy.x = leftLimit;
      // もし targetX が左側に設定されていたら、再設定して左半分に入らないようにする
      if (enemy.targetX < leftLimit) {
        enemy.targetX = leftLimit + Math.random() * Math.max(1, (enemy.patrolRight - leftLimit));
      }
      // vx は左向きなら反転させて少し押し戻す（自然に見せる）
      if (enemy.vx < 0) enemy.vx = Math.abs(enemy.vx) * 0.4;
    }

    // 目標到達時やランダムで新しい targetX を選ぶが、必ず左半分より右に
    if (Math.abs(dx) < 10 || Math.random() < 0.002) {
      const minTarget = Math.max(enemy.patrolLeft, leftLimit);
      enemy.targetX = minTarget + Math.random() * Math.max(1, (enemy.patrolRight - minTarget));
    }

    if (now - enemy.lastManeuver > enemy.maneuverInterval) {
      enemy.lastManeuver = now;
      enemy.maneuverInterval = 600 + Math.random()*1400;
      const burst = (Math.random() < 0.5 ? -1 : 1) * (20 + Math.random()*40) * (1 + score * 0.01);
      enemy.vx += burst;
      enemy.vy += (Math.random()*2 - 1) * 40;
    }

    // 回避は上下移動のみ（vx を大きく変えない）
    if (enemy.dodgeCooldown <= 0) {
      let nearest = null;
      let nearestDist = 99999;
      for (let b of playerBullets) {
        const ddx = b.x - enemy.x;
        const ddy = b.y - (enemy.y + wobbleOffset);
        const dist = Math.hypot(ddx, ddy);
        if (dist < nearestDist) { nearestDist = dist; nearest = b; }
      }
      if (nearest && nearestDist < 140) {
        const dir = (nearest.y > enemy.y + wobbleOffset) ? -1 : 1;
        enemy.vy += dir * (48 + Math.random()*36);
        enemy.dodgeCooldown = 0.35 + Math.random()*0.6;
      }
    } else {
      enemy.dodgeCooldown -= dt;
    }

    enemy.vy *= 0.94;
    enemy.y += enemy.vy * dt;

    const minY = 40;
    const maxY = h - 40;
    if (enemy.y < minY) { enemy.y = minY; enemy.vy = Math.abs(enemy.vy)*0.4; }
    if (enemy.y > maxY) { enemy.y = maxY; enemy.vy = -Math.abs(enemy.vy)*0.4; }

    enemy.fireTimer += dtMs;
    const adjustedFireInterval = Math.max(500, enemy.fireInterval - Math.floor(score * 4));
    if (enemy.fireTimer >= adjustedFireInterval) {
      enemy.fireTimer = 0;
      enemy.patternPhase = (enemy.patternPhase + 1) % 3;
      fireEnemyPattern(enemy.patternPhase);
      enemy.fireInterval = ENEMY_FIRE_BASE_MIN + Math.floor(Math.random()*ENEMY_FIRE_RANDOM);
    }
  }

  function computeBulletCount(base) {
    const extra = Math.floor(score * 0.08);
    const n = Math.min(22, base + extra);
    return Math.max(1, n);
  }

  function fireEnemyPattern(phase) {
    if (!enemy) return;
    const ex = enemy.x - enemy.r*0.6;
    const ey = enemy.y + Math.sin(enemy.wobblePhase) * enemy.wobbleAmp;

    if (phase === 0) {
      const base = 5;
      const n = computeBulletCount(base);
      for (let i=0;i<n;i++){
        const a = (i / n) * Math.PI * 2;
        const s = 110 + Math.random()*30 + Math.min(80, score * 0.8);
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s, vy: Math.sin(a)*s, r: 4, ttl: 6000 });
      }
    } else if (phase === 1) {
      const base = 3;
      const n = computeBulletCount(base);
      const dx = ship.x - ex, dy = ship.y - ey;
      const baseAng = Math.atan2(dy, dx);
      const spread = 0.5 + Math.min(1.0, score * 0.008);
      for (let i=0;i<n;i++){
        const a = baseAng + (i - (n-1)/2) * (spread / Math.max(1, (n-1)));
        const s = 140 + Math.random()*40 + Math.min(80, score * 0.8);
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s, vy: Math.sin(a)*s, r: 4, ttl: 6000 });
      }
    } else {
      const base = 2;
      const n = computeBulletCount(base);
      for (let i=0;i<n;i++){
        const a = Math.PI * 0.18 * (i - (n-1)/2);
        const s = 110 + Math.random()*30 + Math.min(70, score * 0.6);
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s - 80, vy: Math.sin(a)*s, r: 4, ttl: 7000, homing: true });
      }
    }
    playHitSound();
  }

  function updateBullets(dtMs) {
    const dt = dtMs / 1000;
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.x > canvas.clientWidth + 20 || b.y < -20 || b.y > canvas.clientHeight + 20) playerBullets.splice(i,1);
    }
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (b.homing) {
        const ax = ship.x - b.x, ay = ship.y - b.y;
        const ang = Math.atan2(ay, ax);
        const speed = Math.hypot(b.vx, b.vy) || 120;
        const blend = 0.06;
        b.vx = b.vx * (1 - blend) + Math.cos(ang) * speed * blend;
        b.vy = b.vy * (1 - blend) + Math.sin(ang) * speed * blend;
      }
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.ttl -= dtMs;
      if (b.ttl <= 0 || b.x < -40 || b.x > canvas.clientWidth + 40 || b.y < -40 || b.y > canvas.clientHeight + 40) enemyBullets.splice(i,1);
    }
  }

  function checkCollisions() {
    if (enemy) {
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        const dx = b.x - enemy.x;
        const dy = b.y - (enemy.y + Math.sin(enemy.wobblePhase) * enemy.wobbleAmp);
        if (dx*dx + dy*dy < (b.r + enemy.r)*(b.r + enemy.r)) {
          playerBullets.splice(i,1);
          enemy.hp -= 1;
          playHitSound();
          enemy.vx += (Math.random() < 0.5 ? -1 : 1) * 40;
          enemy.vy += (Math.random()*2 - 1) * 40;
          if (enemy.hp <= 0) {
            playExplodeSound();
            enemy = null;
            enemyActive = false;
            enemyBullets.length = 0;
            lastPipeTime = performance.now();
            nextPipeDelay = currentIntervalMax();
            return;
          }
        }
      }
    }

    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (circleRectIntersect(ship.x, ship.y, ship.r, b.x - b.r, b.y - b.r, b.r*2, b.r*2)) {
        enemyBullets.splice(i,1);
        endGame();
        return;
      }
    }

    for (let p of pipes) {
      const topRect = { x: p.x, y: 0, w: PIPE_WIDTH, h: p.top };
      const bottomRect = { x: p.x, y: p.top + p.gap, w: PIPE_WIDTH, h: canvas.clientHeight - (p.top + p.gap) };
      if (circleRectIntersect(ship.x, ship.y, ship.r, topRect.x, topRect.y, topRect.w, topRect.h) ||
          circleRectIntersect(ship.x, ship.y, ship.r, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)) {
        endGame();
        return;
      }
    }
  }

  function drawBackground() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#041426');
    g.addColorStop(0.5, '#071428');
    g.addColorStop(1, '#081a2a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const now = performance.now();
    for (let i=0;i<nebulaLayers.length;i++){
      const nl = nebulaLayers[i];
      const t = (now * nl.speed + nl.offset) % (w*2);
      ctx.save();
      ctx.globalAlpha = nl.alpha;
      const cx = (Math.sin(now*0.00012 + nl.offset*0.001) * 0.5 + 0.5) * w;
      const cy = (Math.cos(now*0.00009 + nl.offset*0.001) * 0.25 + 0.35) * h;
      const rx = w * nl.scale;
      const ry = h * nl.scale * 0.45;
      const rg = ctx.createRadialGradient(cx, cy, Math.min(40, rx*0.06), cx, cy, rx);
      rg.addColorStop(0, nl.colorB);
      rg.addColorStop(0.5, nl.colorA);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.ellipse(cx + (t % (w*1.2)) - w*0.6, cy, rx, ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    for (let s of stars) {
      const layer = starLayers[s.layer];
      const sx = (s.x * w - (now * layer.speed * (s.layer+1) * 0.6) - layer.offset + w*10) % w;
      const sy = (s.y * h + Math.sin((now + s.tw) / (800 + s.layer*120)) * 6 * (s.layer+0.2)) % h;
      let occluded = false;
      for (let p of pipes) {
        const px = p.x;
        const pw = PIPE_WIDTH;
        if (sx >= px && sx <= px + pw && sy >= 0 && sy <= p.top) { occluded = true; break; }
        if (sx >= px && sx <= px + pw && sy >= p.top + p.gap && sy <= h) { occluded = true; break; }
      }
      if (occluded) continue;
      ctx.globalAlpha = 0.7 - s.layer*0.18;
      ctx.fillStyle = layer.color;
      const size = s.size * (1 + 0.2 * Math.sin((now + s.tw)/600));
      ctx.fillRect(sx, sy, size, size);
    }
    ctx.globalAlpha = 1;

    for (let m of meteors) {
      m.t += 16;
      if (m.t > m.life + 2000) {
        if (Math.random() < 0.02) {
          m.x = 1.1 + Math.random()*0.6;
          m.y = Math.random()*0.4;
          m.vx = -0.002 - Math.random()*0.006;
          m.vy = 0.001 + Math.random()*0.003;
          m.life = 800 + Math.random()*2200;
          m.t = 0;
          m.size = 1 + Math.random()*2;
        }
      } else if (m.t < m.life) {
        const mx = (m.x + m.vx * (m.t/1000)) * w;
        const my = (m.y + m.vy * (m.t/1000)) * h;
        ctx.save();
        ctx.globalAlpha = 0.9 * (1 - m.t / m.life);
        ctx.strokeStyle = 'rgba(255,255,220,0.9)';
        ctx.lineWidth = Math.max(1, m.size);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx - m.vx*80*w, my - m.vy*80*h);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.drawImage(noise, 0, 0, w, h);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#000';
    for (let y=0; y<h; y+=2) ctx.fillRect(0, y, w, 1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const vg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.1, w/2, h/2, Math.max(w,h)*0.9);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.28)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function drawSpacePipe(p) {
    const x = p.x;
    const w = PIPE_WIDTH;
    const h = canvas.clientHeight;
    const top = p.top;
    const gap = p.gap;
    const hue = p.hue;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `rgba(${hslToRgb(hue, 60, 50).join(',')}, 0.28)`;
    if (x - 8 < canvas.clientWidth) {
      ctx.fillRect(x - 8, 0, 8, top);
      ctx.fillRect(x - 8, top + gap, 8, h - (top + gap));
      ctx.fillRect(x + w, 0, 8, top);
      ctx.fillRect(x + w, top + gap, 8, h - (top + gap));
    }
    ctx.restore();

    const gradTop = ctx.createLinearGradient(x, 0, x + w, 0);
    gradTop.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradTop.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradTop.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradTop;
    ctx.fillRect(x, 0, w, top);

    const gradBottom = ctx.createLinearGradient(x, 0, x + w, 0);
    gradBottom.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradBottom.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradBottom.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradBottom;
    ctx.fillRect(x, top + gap, w, h - (top + gap));

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${hue} 60% 80%)`;
    ctx.lineWidth = 1;
    for (let i = 0; i < PIPE_STRIPES; i++) {
      const sx = x + (i + 1) * (w / (PIPE_STRIPES + 1));
      ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, top); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sx, top + gap); ctx.lineTo(sx, h); ctx.stroke();
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.9;
    const edgeGrad = ctx.createLinearGradient(x, 0, x + w, 0);
    edgeGrad.addColorStop(0, 'rgba(255,255,255,0.18)');
    edgeGrad.addColorStop(0.5, 'rgba(255,255,255,0.06)');
    edgeGrad.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(x + 2, 0, 4, top);
    ctx.fillRect(x + 2, top + gap, 4, h - (top + gap));
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(x + w - 6, 0, 6, top);
    ctx.fillRect(x + w - 6, top + gap, 6, h - (top + gap));
    ctx.restore();

    if (Math.random() < SPARK_CHANCE) {
      p.sparkleTimer = 200 + Math.random() * 300;
      p.sparkX = x + Math.random() * w;
      p.sparkY = (Math.random() < 0.5) ? (Math.random() * top) : (top + gap + Math.random() * (h - (top + gap)));
    }
    if (p.sparkleTimer > 0) {
      const t = p.sparkleTimer;
      const a = Math.min(1, t / 120);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = 'rgba(255,255,220,0.95)';
      ctx.beginPath();
      ctx.arc(p.sparkX, p.sparkY, 2 + Math.random()*1.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      p.sparkleTimer -= 16;
    }

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${(hue + 40) % 360} 70% 60%)`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.ellipse(x + w - 6, Math.max(12, top - 8), 8, 3, Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x + w - 6, top + gap + 8, 8, 3, -Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawShipOriginal(cx, cy, r, angle, thrusting) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    const grad = ctx.createLinearGradient(-r, -r, r, r);
    grad.addColorStop(0, '#cfd8dc');
    grad.addColorStop(1, '#9aa6ad');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r*0.85, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#2ec4ff';
    ctx.beginPath();
    ctx.ellipse(r*0.18, -r*0.12, r*0.36, r*0.26, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(r*0.28, -r*0.22, r*0.12, r*0.08, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#b0bec5';
    ctx.beginPath();
    ctx.moveTo(-r*0.9, -r*0.15);
    ctx.lineTo(-r*1.4, -r*0.45);
    ctx.lineTo(-r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(r*0.9, -r*0.15);
    ctx.lineTo(r*1.4, -r*0.45);
    ctx.lineTo(r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#7b8a8f';
    ctx.beginPath();
    ctx.ellipse(0, r*0.6, r*0.35, r*0.18, 0, 0, Math.PI*2);
    ctx.fill();

    if (thrusting) {
      const t = performance.now() / 60;
      for (let i = 0; i < 3; i++) {
        const fx = (Math.sin(t + i) * r * 0.06);
        const fy = r*0.9 + Math.abs(Math.sin(t*1.5 + i))*r*0.25;
        ctx.fillStyle = i===0 ? 'rgba(255,180,60,0.95)' : (i===1 ? 'rgba(255,120,40,0.85)' : 'rgba(255,80,20,0.7)');
        ctx.beginPath();
        ctx.ellipse(fx, fy, r*0.18 - i*0.04, r*0.28 - i*0.06, Math.PI*0.1*i, 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      ctx.fillStyle = 'rgba(255,140,60,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, r*0.95, r*0.12, r*0.06, 0, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawEnemy() {
    if (!enemy) return;
    ctx.save();
    const wobbleOffset = Math.sin(enemy.wobblePhase) * enemy.wobbleAmp;
    ctx.translate(enemy.x, enemy.y + wobbleOffset);
    const r = enemy.r;
    const hue = enemy.hue !== undefined ? enemy.hue : 280;
    const grad = ctx.createLinearGradient(-r, -r, r, r);
    grad.addColorStop(0, `hsl(${hue} 60% 60%)`);
    grad.addColorStop(1, `hsl(${(hue+40)%360} 60% 30%)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r*0.6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.ellipse(-r*0.12, -r*0.18, r*0.42, r*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(-r, r*0.5, r*2, 6);
    ctx.fillStyle = '#ff6b6b';
    const hpW = (enemy.hp / ENEMY_HP_CAP) * (r*2);
    ctx.fillRect(-r, r*0.5, hpW, 6);
    ctx.restore();
  }

  function drawBullets() {
    for (let b of playerBullets) {
      ctx.save();
      ctx.fillStyle = '#ffd86b';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    for (let b of enemyBullets) {
      ctx.save();
      ctx.fillStyle = '#ff7bff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function draw() {
    drawBackground();
    for (let p of pipes) drawSpacePipe(p);
    drawEnemy();
    drawBullets();
    ship.x = Math.max(ship.r + 8, Math.min(ship.x, canvas.clientWidth - ship.r - 8));
    drawShipOriginal(ship.x, ship.y, ship.r, ship.angle, ship.thrusting);
  }

  function update(dtMs) {
    if (!running) return;
    const dt = dtMs / 1000;
    ship.vy += GRAVITY;
    ship.y += ship.vy;

    const targetAngle = ship.vy < 0 ? -0.5 : Math.min(1.0, ship.vy / 12);
    ship.angle += (targetAngle - ship.angle) * 0.08;

    if (enemyActive) updateEnemy(dtMs);

    const pipeSpeed = currentPipeSpeedPPS();
    for (let p of pipes) {
      p.x -= pipeSpeed * dt;
      if (!p.passed && p.x + PIPE_WIDTH < ship.x - ship.r) {
        p.passed = true;
        score++;
        scoreEl.textContent = 'Score: ' + score;
      }
    }
    pipes = pipes.filter(p => p.x + PIPE_WIDTH > -40);

    if (performance.now() - lastPipeTime > nextPipeDelay) spawnPipe();

    if (!enemyActive && !enemy && score >= 5 && score >= lastEnemySpawnScore + ENEMY_SPAWN_SCORE_GAP) {
      spawnEnemyUFO();
    }

    updateBullets(dtMs);
    checkCollisions();

    const groundY = canvas.clientHeight;
    if (ship.y + ship.r > groundY || ship.y - ship.r < 0) {
      endGame();
    }
  }

  function evaluateScore(s) {
    if (s >= 60) return '伝説のUFO操縦士';
    if (s >= 30) return '熟練UFO操縦士';
    if (s >= 10) return '見習いUFO操縦士';
    return '初心者UFO操縦士';
  }

  function endGame() {
    running = false;
    gameOver = true;
    ship.thrusting = false;
    finalScoreEl.textContent = score;
    finalEvalEl.textContent = evaluateScore(score);
    musicCreditEl.textContent = 'music: ConteDeFees, FC音工場';
    gameOverPanel.style.display = 'block';
    gameOverPanel.setAttribute('aria-hidden', 'false');
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'ゲームオーバー\nScore: ' + score + '\n評価: ' + evaluateScore(score);

    initAudioIfNeeded().then(()=>{
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      playHitSound();
      pauseBgm();
      playGameoverBgm();
    }).catch(()=>{
      playHitSound();
      pauseBgm();
      playGameoverBgm();
    });

    applySepiaTransition(900);
    ignoreInputUntil = performance.now() + 1000;
  }

  function reset() {
    stopGameoverBgm();

    ship = { x: 80, y: canvas.clientHeight/2 - 10, vy: 0, r: 22, angle: 0, thrusting: false };
    pipes = [];
    playerBullets.length = 0;
    enemyBullets.length = 0;
    enemy = null;
    enemyActive = false;
    score = 0;
    lastEnemySpawnScore = -9999;
    scoreEl.textContent = 'Score: 0';
    running = false;
    gameOver = false;
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'タップしてスタート';
    startTime = null;
    lastPipeTime = performance.now();
    nextPipeDelay = INITIAL_INTERVAL_MAX;
    gameOverPanel.style.display = 'none';
    gameOverPanel.setAttribute('aria-hidden', 'true');

    try {
      if (htmlGameoverAudio && !htmlGameoverAudio.paused) { htmlGameoverAudio.pause(); try { htmlGameoverAudio.currentTime = 0; } catch(e){} }
    } catch(e){}
    pauseBgm();

    clearSepiaTransition(220);
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function start() {
    stopGameoverBgm();

    running = true;
    gameOver = false;
    messageEl.style.display = 'none';
    messageEl.textContent = '';
    startTime = performance.now();
    lastPipeTime = performance.now();
    if (pipes.length === 0) spawnPipe();

    clearSepiaTransition(120);

    initAudioIfNeeded().then(()=>{
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      playBgm();
    }).catch(()=>{ playBgm(); });
  }

  // --- デバッグ用: キーボード U でスコアを +1 ---
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') { onPointerDown(e); }
    if (e.code === 'KeyU') {
      score++;
      scoreEl.textContent = 'Score: ' + score;
    }
  });

  reset();
  requestAnimationFrame(loop);
  document.addEventListener('visibilitychange', () => { if (document.hidden) pauseBgm(); else if (running) playBgm(); });

})();
</script>
</body>
</html>