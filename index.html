<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>宇宙風パイプ（敵UFO・弾幕・自機ショット対応）</title>
<style>
  html,body { height:100%; margin:0; background:#021022; -webkit-tap-highlight-color: transparent; }
  canvas#game {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    background: linear-gradient(#071428,#0b2a44);
  }
  .overlay { position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
  #score { position:absolute; left:12px; top:12px; z-index:30; font-size:20px; color:#fff; text-shadow:0 2px 6px rgba(0,0,0,0.6); pointer-events:auto; background: rgba(255,255,255,0.06); padding:6px 10px; border-radius:8px; }
  .center { position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); text-align:center; z-index:30; pointer-events:auto; }
  #message { font-size:18px; color:#fff; text-shadow:0 2px 4px rgba(0,0,0,0.5); background: rgba(0,0,0,0.18); display:inline-block; padding:8px 12px; border-radius:8px; white-space:pre-line; }
  #gameOverPanel { position: absolute; left: 50%; top: 36%; transform: translate(-50%, -50%); z-index: 40; pointer-events: none; text-align: center; color: #fff; display: none; }
  #finalScore { font-size: 48px; font-weight: 700; color: #ffd86b; text-shadow: 0 6px 18px rgba(0,0,0,0.6); margin-bottom: 8px; }
  #finalEval { font-size: 22px; color: #bfefff; margin-bottom: 6px; }
  #musicCredit { font-size: 14px; color: rgba(255,255,255,0.85); margin-top: 6px; }
  #retryHint { font-size: 14px; color: rgba(255,255,255,0.85); margin-top:6px; }
  @media (max-width:420px){
    #message{ font-size:16px; padding:6px 10px; }
    #finalScore{ font-size:36px; }
    #finalEval{ font-size:18px; }
    #musicCredit{ font-size:13px; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="overlay" aria-hidden="false">
  <div id="score">Score: 0</div>
  <div class="center" id="centerMessage"><div id="message">タップしてスタート</div></div>
</div>

<div id="gameOverPanel" aria-hidden="true">
  <div id="finalScore">0</div>
  <div id="finalEval">評価</div>
  <div id="musicCredit">music: ConteDeFees, FC音工場</div>
  <div id="retryHint">1秒後にタップで再開できます</div>
</div>

<script>
(() => {
  // --- audio file paths (adjust to your project) ---
  const JUMP_SOUND_SRC = 'assets/jump.wav';
  const BGM_SRC = 'assets/bgm.mp3';
  const HIT_SOUND_SRC = 'assets/hit.wav';
  const EXPLODE_SOUND_SRC = 'assets/explode.wav';

  // --- DOM ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const gameOverPanel = document.getElementById('gameOverPanel');
  const finalScoreEl = document.getElementById('finalScore');
  const finalEvalEl = document.getElementById('finalEval');
  const musicCreditEl = document.getElementById('musicCredit');

  // --- audio (HTMLAudio fallback + optional AudioContext decode) ---
  let htmlJumpAudio = null, htmlBgmAudio = null, htmlHitAudio = null, htmlExplodeAudio = null;
  let audioInitialized = false;
  let audioCtx = null, jumpBuffer = null, hitBuffer = null, explodeBuffer = null;

  async function initAudioIfNeeded() {
    if (audioInitialized) return;
    try { htmlJumpAudio = new Audio(JUMP_SOUND_SRC); htmlJumpAudio.preload = 'auto'; } catch(e){ htmlJumpAudio = null; }
    try { htmlBgmAudio = new Audio(BGM_SRC); htmlBgmAudio.preload = 'auto'; htmlBgmAudio.loop = true; htmlBgmAudio.volume = 0.45; } catch(e){ htmlBgmAudio = null; }
    try { htmlHitAudio = new Audio(HIT_SOUND_SRC); htmlHitAudio.preload = 'auto'; } catch(e){ htmlHitAudio = null; }
    try { htmlExplodeAudio = new Audio(EXPLODE_SOUND_SRC); htmlExplodeAudio.preload = 'auto'; } catch(e){ htmlExplodeAudio = null; }

    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) {
        audioCtx = new Ctx();
        // try decode effects (may fail on file://)
        const jResp = await fetch(JUMP_SOUND_SRC).catch(()=>null);
        if (jResp && jResp.ok) { const ab = await jResp.arrayBuffer().catch(()=>null); if (ab) jumpBuffer = await audioCtx.decodeAudioData(ab).catch(()=>null); }
        const hResp = await fetch(HIT_SOUND_SRC).catch(()=>null);
        if (hResp && hResp.ok) { const ab2 = await hResp.arrayBuffer().catch(()=>null); if (ab2) hitBuffer = await audioCtx.decodeAudioData(ab2).catch(()=>null); }
        const eResp = await fetch(EXPLODE_SOUND_SRC).catch(()=>null);
        if (eResp && eResp.ok) { const ab3 = await eResp.arrayBuffer().catch(()=>null); if (ab3) explodeBuffer = await audioCtx.decodeAudioData(ab3).catch(()=>null); }
      }
    } catch(e) {
      audioCtx = null; jumpBuffer = null; hitBuffer = null; explodeBuffer = null;
    }
    audioInitialized = true;
  }

  function playBuffer(buffer, vol=1.0) {
    try {
      if (audioCtx && buffer) {
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const g = audioCtx.createGain();
        g.gain.value = vol;
        src.connect(g);
        g.connect(audioCtx.destination);
        src.start(0);
        return true;
      }
    } catch(e){}
    return false;
  }

  function playJumpSound() {
    if (playBuffer(jumpBuffer, 0.9)) return;
    if (htmlJumpAudio) { const a = htmlJumpAudio.cloneNode(true); a.volume = 0.9; a.play().catch(()=>{}); }
  }
  function playHitSound() {
    if (playBuffer(hitBuffer, 1.0)) return;
    if (htmlHitAudio) { const a = htmlHitAudio.cloneNode(true); a.volume = 1.0; a.play().catch(()=>{}); }
  }
  function playExplodeSound() {
    if (playBuffer(explodeBuffer, 1.0)) return;
    if (htmlExplodeAudio) { const a = htmlExplodeAudio.cloneNode(true); a.volume = 1.0; a.play().catch(()=>{}); }
  }

  function playBgm() {
    try {
      if (!htmlBgmAudio) return;
      htmlBgmAudio.pause();
      try { htmlBgmAudio.currentTime = 0; } catch(e){}
      htmlBgmAudio.play().catch(()=>{});
    } catch(e){}
  }
  function pauseBgm() {
    try {
      if (!htmlBgmAudio) return;
      if (!htmlBgmAudio.paused) htmlBgmAudio.pause();
      try { htmlBgmAudio.currentTime = 0; } catch(e){}
    } catch(e){}
  }

  // --- canvas resize ---
  function resize() {
    const ratio = window.devicePixelRatio || 1;
    const w = Math.max(window.innerWidth, 320);
    const h = Math.max(window.innerHeight, 320);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * ratio);
    canvas.height = Math.floor(h * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- game constants & state ---
  const INITIAL_GAP = 300;
  const MIN_GAP = 80;
  const SCORE_RAMP_MAX = 100;
  const RAMP_DURATION_MS = 30000;
  const INITIAL_INTERVAL_MAX = 2600;
  const MIN_INTERVAL = 1800;
  const INTERVAL_RAMP_MS = 30000;
  const GRAVITY = 0.6;
  const THRUST = -10;
  const PIPE_WIDTH = 52;
  const PIPE_SPEED_BASE = 2.2;
  const PIPE_STRIPES = 3;
  const SPARK_CHANCE = 0.006;
  const COLOR_HUES = [200,160,280,40,10,120,260,340,30,195];

  let ship = { x: 80, y: 150, vy: 0, r: 22, angle: 0, thrusting: false };
  let pipes = [];
  let lastPipeTime = 0;
  let nextPipeDelay = INITIAL_INTERVAL_MAX;
  let score = 0;
  let running = false;
  let gameOver = false;
  let lastTime = 0;
  let startTime = null;
  let ignoreInputUntil = 0;

  // --- enemy UFO state ---
  let enemyActive = false;
  let enemySpawnedForScore5 = false; // ensure triggers once when score reaches 5
  let enemy = null; // {x,y,vx,vy,hp,fireTimer,phase}
  const ENEMY_HP = 3;

  // --- bullets ---
  const playerBullets = []; // {x,y,vx,vy,r}
  const enemyBullets = [];  // {x,y,vx,vy,r,ttl}

  // --- background assets / particles ---
  const starLayers = [
    {count: 80, speed: 0.02, sizeRange: [0.6,1.6], color: '#e8f8ff', offset: Math.random()*1000},
    {count: 40, speed: 0.06, sizeRange: [1.2,2.6], color: '#cfefff', offset: Math.random()*1000},
    {count: 18, speed: 0.12, sizeRange: [1.8,3.6], color: '#ffffff', offset: Math.random()*1000}
  ];
  const stars = [];
  for (let li=0; li<starLayers.length; li++){
    const layer = starLayers[li];
    for (let i=0;i<layer.count;i++){
      stars.push({
        layer: li,
        x: Math.random(),
        y: Math.random(),
        size: layer.sizeRange[0] + Math.random()*(layer.sizeRange[1]-layer.sizeRange[0]),
        tw: Math.random()*1000
      });
    }
  }
  const nebulaLayers = [
    {colorA: '#0b2a44', colorB: '#1b4a66', alpha: 0.12, speed: 0.02, scale: 1.6, offset: Math.random()*1000},
    {colorA: '#122b3f', colorB: '#0f3a5a', alpha: 0.08, speed: 0.035, scale: 1.1, offset: Math.random()*1000},
    {colorA: '#0f2b44', colorB: '#072a3a', alpha: 0.06, speed: 0.06, scale: 0.8, offset: Math.random()*1000}
  ];
  const meteors = [];
  for (let i=0;i<12;i++){
    meteors.push({
      x: Math.random(), y: Math.random(), vx: -0.002 - Math.random()*0.006, vy: 0.001 + Math.random()*0.003,
      life: Math.random()*4000, t: Math.random()*6000, size: 1 + Math.random()*2
    });
  }
  function createNoiseCanvas(w,h,alpha){
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const g = c.getContext('2d');
    const img = g.createImageData(w,h);
    for (let i=0;i<img.data.length;i+=4){
      const v = 200 + Math.floor(Math.random()*55);
      img.data[i]=v; img.data[i+1]=v; img.data[i+2]=v; img.data[i+3]=Math.floor(255*alpha*Math.random());
    }
    g.putImageData(img,0,0);
    return c;
  }
  const noise = createNoiseCanvas(128,128,0.04);

  // --- helpers ---
  function difficultyFactor(){ if(!startTime) return 0; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/RAMP_DURATION_MS); return t*t; }
  function currentIntervalMax(){ if(!startTime) return INITIAL_INTERVAL_MAX; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/INTERVAL_RAMP_MS); const f=t*t; return Math.round(INITIAL_INTERVAL_MAX + (MIN_INTERVAL - INITIAL_INTERVAL_MAX)*f); }
  function currentPipeSpeed(){ const f=difficultyFactor(); return PIPE_SPEED_BASE + (3.0 - PIPE_SPEED_BASE)*f; }
  function gapAtSpawn() { const sf = Math.min(1, score / SCORE_RAMP_MAX); return Math.round(INITIAL_GAP + (MIN_GAP - INITIAL_GAP) * sf); }
  function circleRectIntersect(cx, cy, r, rx, ry, rw, rh){ const nearestX = Math.max(rx, Math.min(cx, rx + rw)); const nearestY = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - nearestX; const dy = cy - nearestY; return (dx*dx + dy*dy) < (r*r); }
  function hslToRgb(h,s,l){ s/=100; l/=100; const k = n => (n + h/30) % 12; const a = s * Math.min(l,1-l); const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); return [Math.round(255*f(0)), Math.round(255*f(8)), Math.round(255*f(4))]; }

  // --- input handlers ---
  function onPointerDown(e){
    if (e.cancelable) e.preventDefault();
    initAudioIfNeeded().then(()=>{ if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); }).catch(()=>{});
    if (performance.now() < ignoreInputUntil) return;
    if (gameOver){ reset(); start(); return; }
    if (!running){ start(); return; }

    // jump + fire player bullet
    ship.vy = THRUST;
    ship.thrusting = true;
    ship.angle = -0.5;
    // spawn player bullet from nose
    const bx = ship.x + ship.r * 0.9;
    const by = ship.y - ship.r*0.08;
    const speed = 6;
    playerBullets.push({ x: bx, y: by, vx: speed, vy: 0, r: 5 });
    playJumpSound();
  }
  function onPointerUp(e){ if (e.cancelable) e.preventDefault(); ship.thrusting = false; }
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointerup', onPointerUp, {passive:false});
  canvas.addEventListener('pointercancel', onPointerUp, {passive:false});
  document.body.addEventListener('pointerdown', onPointerDown, {passive:false});
  document.body.addEventListener('pointerup', onPointerUp, {passive:false});

  // --- spawn pipe & enemy trigger ---
  function spawnPipe(){
    const ch = canvas.clientHeight;
    const gap = gapAtSpawn();
    const minTop = 40;
    const maxTop = ch - gap - 40;
    const top = Math.floor(Math.random() * Math.max(1, (maxTop - minTop + 1))) + minTop;
    const bucket = Math.floor(score / 10);
    const hue = COLOR_HUES[bucket % COLOR_HUES.length];
    // Ensure horizontal spacing between pipes doesn't become too small:
    // If last pipe exists and is too close to right edge, delay spawn by resetting lastPipeTime.
    const minPixelSpacing = Math.max(220, PIPE_WIDTH * 2); // ensure at least this many pixels between spawns
    if (pipes.length > 0) {
      const last = pipes[pipes.length - 1];
      const rightEdge = canvas.clientWidth;
      const lastDistance = last.x - (rightEdge);
      // If last.x is already near the spawn position (meaning previous pipe spawned very recently),
      // postpone this spawn by setting lastPipeTime to now so nextPipeDelay will be respected.
      if (last.x > canvas.clientWidth - minPixelSpacing) {
        lastPipeTime = performance.now();
        nextPipeDelay = Math.max(nextPipeDelay, currentIntervalMax());
        return;
      }
    }

    pipes.push({ x: canvas.clientWidth + 10, top: top, gap: gap, hue: hue, passed: false, sparkleTimer: 0 });
    const intervalMax = currentIntervalMax();
    const range = Math.max(0, intervalMax - MIN_INTERVAL);
    // choose nextPipeDelay within [MIN_INTERVAL, intervalMax], but also enforce a safe minimum
    const chosen = MIN_INTERVAL + Math.floor(Math.random() * (range + 1));
    nextPipeDelay = Math.max(chosen, 1000); // never below 1000ms as extra safety
    lastPipeTime = performance.now();
  }

  // --- enemy spawn function ---
  function spawnEnemyUFO() {
    // stop pipes by setting enemyActive true; pipes won't move while enemyActive
    enemyActive = true;
    enemy = {
      x: canvas.clientWidth + 80,
      y: canvas.clientHeight * 0.25,
      vx: -2.2,
      vy: 0,
      r: 34,
      hp: ENEMY_HP,
      fireTimer: 0,
      fireInterval: 900, // ms between volleys
      patternPhase: 0,
      entryDone: false
    };
  }

  // --- enemy behavior: move in, then hover and fire patterns ---
  function updateEnemy(dt) {
    if (!enemy) return;
    // entry: move to a target x then hover
    if (!enemy.entryDone) {
      enemy.x += enemy.vx;
      // slow down and stop at 70% width
      const targetX = canvas.clientWidth * 0.68;
      if (enemy.x <= targetX) {
        enemy.x = targetX;
        enemy.entryDone = true;
        enemy.vx = 0;
        enemy.fireTimer = 0;
      }
      return;
    }
    // hover vertical oscillation
    enemy.y += Math.sin(performance.now() * 0.002 + enemy.patternPhase) * 0.6;
    // firing
    enemy.fireTimer += dt;
    if (enemy.fireTimer >= enemy.fireInterval) {
      enemy.fireTimer = 0;
      enemy.patternPhase = (enemy.patternPhase + 1) % 3;
      fireEnemyPattern(enemy.patternPhase);
    }
  }

  // --- enemy firing patterns (simple variations) ---
  function fireEnemyPattern(phase) {
    const ex = enemy.x - enemy.r*0.6;
    const ey = enemy.y;
    if (phase === 0) {
      // radial burst of 12 bullets
      const n = 12;
      for (let i=0;i<n;i++){
        const a = (i / n) * Math.PI * 2;
        const s = 2.2;
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s, vy: Math.sin(a)*s, r: 4, ttl: 6000 });
      }
    } else if (phase === 1) {
      // aimed spread toward player: 7 bullets fan
      const dx = ship.x - ex, dy = ship.y - ey;
      const base = Math.atan2(dy, dx);
      const spread = 0.6;
      const n = 7;
      for (let i=0;i<n;i++){
        const a = base + (i - (n-1)/2) * (spread / (n-1));
        const s = 3.2;
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s, vy: Math.sin(a)*s, r: 4, ttl: 6000 });
      }
    } else {
      // slow homing-ish bullets (initially aimed, then slight curve)
      const n = 6;
      for (let i=0;i<n;i++){
        const a = Math.PI * 0.2 * (i - (n-1)/2);
        const s = 2.0;
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(a)*s - 1.2, vy: Math.sin(a)*s, r: 4, ttl: 7000, homing: true });
      }
    }
    playHitSound(); // small sound to indicate enemy fired (reusing hit sound)
  }

  // --- update bullets ---
  function updateBullets(dt) {
    // player bullets
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      b.x += b.vx;
      b.y += b.vy;
      // remove off-screen
      if (b.x > canvas.clientWidth + 20 || b.y < -20 || b.y > canvas.clientHeight + 20) playerBullets.splice(i,1);
    }
    // enemy bullets
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      // homing slight adjustment
      if (b.homing) {
        const ax = ship.x - b.x, ay = ship.y - b.y;
        const ang = Math.atan2(ay, ax);
        const speed = Math.hypot(b.vx, b.vy) || 2.2;
        // blend current velocity toward angle
        const blend = 0.06;
        b.vx = b.vx * (1 - blend) + Math.cos(ang) * speed * blend;
        b.vy = b.vy * (1 - blend) + Math.sin(ang) * speed * blend;
      }
      b.x += b.vx;
      b.y += b.vy;
      b.ttl -= dt;
      if (b.ttl <= 0 || b.x < -40 || b.x > canvas.clientWidth + 40 || b.y < -40 || b.y > canvas.clientHeight + 40) enemyBullets.splice(i,1);
    }
  }

  // --- collision checks ---
  function checkCollisions() {
    // player bullets vs enemy
    if (enemy && enemy.entryDone) {
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        const dx = b.x - enemy.x;
        const dy = b.y - enemy.y;
        if (dx*dx + dy*dy < (b.r + enemy.r)*(b.r + enemy.r)) {
          // hit
          playerBullets.splice(i,1);
          enemy.hp -= 1;
          playHitSound();
          // small flash or effect could be added
          if (enemy.hp <= 0) {
            // destroy enemy
            playExplodeSound();
            enemy = null;
            enemyActive = false;
            // resume pipes by leaving spawn logic intact
            // clear enemy bullets
            enemyBullets.length = 0;
            // resume pipes: nothing special needed because enemyActive flag controls movement
            // spawn a small explosion visual by pushing particles (optional)
            // ensure pipes resume by not blocking their movement
            return;
          }
        }
      }
    }

    // enemy bullets vs ship
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (circleRectIntersect(ship.x, ship.y, ship.r, b.x - b.r, b.y - b.r, b.r*2, b.r*2)) {
        // hit player -> immediate game over
        enemyBullets.splice(i,1);
        endGame();
        return;
      }
    }

    // pipes collision (only when not enemyActive)
    if (!enemyActive) {
      for (let p of pipes) {
        const topRect = { x: p.x, y: 0, w: PIPE_WIDTH, h: p.top };
        const bottomRect = { x: p.x, y: p.top + p.gap, w: PIPE_WIDTH, h: canvas.clientHeight - (p.top + p.gap) };
        if (circleRectIntersect(ship.x, ship.y, ship.r, topRect.x, topRect.y, topRect.w, topRect.h) ||
            circleRectIntersect(ship.x, ship.y, ship.r, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)) {
          endGame();
          return;
        }
      }
    }
  }

  // --- drawing functions ---
  function drawBackground() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#041426');
    g.addColorStop(0.5, '#071428');
    g.addColorStop(1, '#081a2a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const now = performance.now();

    for (let i=0;i<nebulaLayers.length;i++){
      const nl = nebulaLayers[i];
      const t = (now * nl.speed + nl.offset) % (w*2);
      ctx.save();
      ctx.globalAlpha = nl.alpha;
      const cx = (Math.sin(now*0.00012 + nl.offset*0.001) * 0.5 + 0.5) * w;
      const cy = (Math.cos(now*0.00009 + nl.offset*0.001) * 0.25 + 0.35) * h;
      const rx = w * nl.scale;
      const ry = h * nl.scale * 0.45;
      const rg = ctx.createRadialGradient(cx, cy, Math.min(40, rx*0.06), cx, cy, rx);
      rg.addColorStop(0, nl.colorB);
      rg.addColorStop(0.5, nl.colorA);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.ellipse(cx + (t % (w*1.2)) - w*0.6, cy, rx, ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    for (let s of stars) {
      const layer = starLayers[s.layer];
      const sx = (s.x * w - (now * layer.speed * (s.layer+1) * 0.6) - layer.offset + w*10) % w;
      const sy = (s.y * h + Math.sin((now + s.tw) / (800 + s.layer*120)) * 6 * (s.layer+0.2)) % h;

      // occlusion: skip star if it's in front of any pipe (top or bottom)
      let occluded = false;
      for (let p of pipes) {
        const px = p.x;
        const pw = PIPE_WIDTH;
        if (sx >= px && sx <= px + pw && sy >= 0 && sy <= p.top) { occluded = true; break; }
        if (sx >= px && sx <= px + pw && sy >= p.top + p.gap && sy <= h) { occluded = true; break; }
      }
      if (occluded) continue;

      ctx.globalAlpha = 0.7 - s.layer*0.18;
      ctx.fillStyle = layer.color;
      const size = s.size * (1 + 0.2 * Math.sin((now + s.tw)/600));
      ctx.fillRect(sx, sy, size, size);
    }
    ctx.globalAlpha = 1;

    for (let m of meteors) {
      m.t += 16;
      if (m.t > m.life + 2000) {
        if (Math.random() < 0.02) {
          m.x = 1.1 + Math.random()*0.6;
          m.y = Math.random()*0.4;
          m.vx = -0.002 - Math.random()*0.006;
          m.vy = 0.001 + Math.random()*0.003;
          m.life = 800 + Math.random()*2200;
          m.t = 0;
          m.size = 1 + Math.random()*2;
        }
      } else if (m.t < m.life) {
        const mx = (m.x + m.vx * (m.t/1000)) * w;
        const my = (m.y + m.vy * (m.t/1000)) * h;
        ctx.save();
        ctx.globalAlpha = 0.9 * (1 - m.t / m.life);
        ctx.strokeStyle = 'rgba(255,255,220,0.9)';
        ctx.lineWidth = Math.max(1, m.size);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx - m.vx*80*w, my - m.vy*80*h);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.drawImage(noise, 0, 0, w, h);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#000';
    for (let y=0; y<h; y+=2) ctx.fillRect(0, y, w, 1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const vg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.1, w/2, h/2, Math.max(w,h)*0.9);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.28)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function drawSpacePipe(p) {
    const x = p.x;
    const w = PIPE_WIDTH;
    const h = canvas.clientHeight;
    const top = p.top;
    const gap = p.gap;
    const hue = p.hue;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `rgba(${hslToRgb(hue, 60, 50).join(',')}, 0.28)`;
    if (x - 8 < canvas.clientWidth) {
      ctx.fillRect(x - 8, 0, 8, top);
      ctx.fillRect(x - 8, top + gap, 8, h - (top + gap));
      ctx.fillRect(x + w, 0, 8, top);
      ctx.fillRect(x + w, top + gap, 8, h - (top + gap));
    }
    ctx.restore();

    const gradTop = ctx.createLinearGradient(x, 0, x + w, 0);
    gradTop.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradTop.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradTop.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradTop;
    ctx.fillRect(x, 0, w, top);

    const gradBottom = ctx.createLinearGradient(x, 0, x + w, 0);
    gradBottom.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradBottom.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradBottom.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradBottom;
    ctx.fillRect(x, top + gap, w, h - (top + gap));

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${hue} 60% 80%)`;
    ctx.lineWidth = 1;
    for (let i = 0; i < PIPE_STRIPES; i++) {
      const sx = x + (i + 1) * (w / (PIPE_STRIPES + 1));
      ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, top); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sx, top + gap); ctx.lineTo(sx, h); ctx.stroke();
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.9;
    const edgeGrad = ctx.createLinearGradient(x, 0, x + w, 0);
    edgeGrad.addColorStop(0, 'rgba(255,255,255,0.18)');
    edgeGrad.addColorStop(0.5, 'rgba(255,255,255,0.06)');
    edgeGrad.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(x + 2, 0, 4, top);
    ctx.fillRect(x + 2, top + gap, 4, h - (top + gap));
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(x + w - 6, 0, 6, top);
    ctx.fillRect(x + w - 6, top + gap, 6, h - (top + gap));
    ctx.restore();

    if (Math.random() < SPARK_CHANCE) {
      p.sparkleTimer = 200 + Math.random() * 300;
      p.sparkX = x + Math.random() * w;
      p.sparkY = (Math.random() < 0.5) ? (Math.random() * top) : (top + gap + Math.random() * (h - (top + gap)));
    }
    if (p.sparkleTimer > 0) {
      const t = p.sparkleTimer;
      const a = Math.min(1, t / 120);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = 'rgba(255,255,220,0.95)';
      ctx.beginPath();
      ctx.arc(p.sparkX, p.sparkY, 2 + Math.random()*1.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      p.sparkleTimer -= 16;
    }

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${(hue + 40) % 360} 70% 60%)`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.ellipse(x + w - 6, Math.max(12, top - 8), 8, 3, Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x + w - 6, top + gap + 8, 8, 3, -Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawShipOriginal(cx, cy, r, angle, thrusting) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    const grad = ctx.createLinearGradient(-r, -r, r, r);
    grad.addColorStop(0, '#cfd8dc');
    grad.addColorStop(1, '#9aa6ad');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r*0.85, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#2ec4ff';
    ctx.beginPath();
    ctx.ellipse(r*0.18, -r*0.12, r*0.36, r*0.26, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(r*0.28, -r*0.22, r*0.12, r*0.08, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#b0bec5';
    ctx.beginPath();
    ctx.moveTo(-r*0.9, -r*0.15);
    ctx.lineTo(-r*1.4, -r*0.45);
    ctx.lineTo(-r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(r*0.9, -r*0.15);
    ctx.lineTo(r*1.4, -r*0.45);
    ctx.lineTo(r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#7b8a8f';
    ctx.beginPath();
    ctx.ellipse(0, r*0.6, r*0.35, r*0.18, 0, 0, Math.PI*2);
    ctx.fill();

    if (thrusting) {
      const t = performance.now() / 60;
      for (let i = 0; i < 3; i++) {
        const fx = (Math.sin(t + i) * r * 0.06);
        const fy = r*0.9 + Math.abs(Math.sin(t*1.5 + i))*r*0.25;
        ctx.fillStyle = i===0 ? 'rgba(255,180,60,0.95)' : (i===1 ? 'rgba(255,120,40,0.85)' : 'rgba(255,80,20,0.7)');
        ctx.beginPath();
        ctx.ellipse(fx, fy, r*0.18 - i*0.04, r*0.28 - i*0.06, Math.PI*0.1*i, 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      ctx.fillStyle = 'rgba(255,140,60,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, r*0.95, r*0.12, r*0.06, 0, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawEnemy() {
    if (!enemy) return;
    // simple UFO shape
    ctx.save();
    ctx.translate(enemy.x, enemy.y);
    // body
    const r = enemy.r;
    const hue = 280;
    const grad = ctx.createLinearGradient(-r, -r, r, r);
    grad.addColorStop(0, `hsl(${hue} 60% 60%)`);
    grad.addColorStop(1, `hsl(${(hue+40)%360} 60% 30%)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r*0.6, 0, 0, Math.PI*2);
    ctx.fill();
    // dome
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.ellipse(-r*0.12, -r*0.18, r*0.42, r*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    // HP indicator
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(-r, r*0.5, r*2, 6);
    ctx.fillStyle = '#ff6b6b';
    const hpW = (enemy.hp / ENEMY_HP) * (r*2);
    ctx.fillRect(-r, r*0.5, hpW, 6);
    ctx.restore();
  }

  function drawBullets() {
    // player bullets
    for (let b of playerBullets) {
      ctx.save();
      ctx.fillStyle = '#ffd86b';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    // enemy bullets
    for (let b of enemyBullets) {
      ctx.save();
      ctx.fillStyle = '#ff7bff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // --- main draw & update loop ---
  function draw() {
    drawBackground();
    for (let p of pipes) drawSpacePipe(p);
    drawEnemy();
    drawBullets();
    ship.x = Math.max(ship.r + 8, Math.min(ship.x, canvas.clientWidth - ship.r - 8));
    drawShipOriginal(ship.x, ship.y, ship.r, ship.angle, ship.thrusting);
  }

  function update(dt) {
    if (!running) return;
    ship.vy += GRAVITY;
    ship.y += ship.vy;
    const targetAngle = ship.vy < 0 ? -0.5 : Math.min(1.0, ship.vy / 12);
    ship.angle += (targetAngle - ship.angle) * 0.08;

    // enemy logic
    if (enemyActive) {
      updateEnemy(dt);
    }

    // pipes movement: only when enemy not active
    const speed = enemyActive ? 0 : currentPipeSpeed();
    for (let p of pipes) {
      p.x -= speed;
      if (!p.passed && p.x + PIPE_WIDTH < ship.x - ship.r) {
        p.passed = true;
        score++;
        scoreEl.textContent = 'Score: ' + score;
      }
    }
    pipes = pipes.filter(p => p.x + PIPE_WIDTH > -40);

    // spawn pipes normally
    if (!enemyActive && performance.now() - lastPipeTime > nextPipeDelay) spawnPipe();

    // spawn enemy when score reaches 5 (only once)
    if (!enemySpawnedForScore5 && score >= 5) {
      enemySpawnedForScore5 = true;
      // stop spawning/moving pipes by setting enemyActive true via spawnEnemyUFO
      spawnEnemyUFO();
    }

    // update bullets
    updateBullets(dt);

    // collisions
    checkCollisions();

    // ground/ceiling check (if enemy active, still collide with bounds)
    const groundY = canvas.clientHeight;
    if (ship.y + ship.r > groundY || ship.y - ship.r < 0) {
      endGame();
    }
  }

  function evaluateScore(s) {
    if (s >= 60) return '伝説のUFO操縦士';
    if (s >= 30) return '熟練UFO操縦士';
    if (s >= 10) return '見習いUFO操縦士';
    return '初心者UFO操縦士';
  }

  function endGame() {
    running = false;
    gameOver = true;
    ship.thrusting = false;
    finalScoreEl.textContent = score;
    finalEvalEl.textContent = evaluateScore(score);
    musicCreditEl.textContent = 'music: ConteDeFees, FC音工場';
    gameOverPanel.style.display = 'block';
    gameOverPanel.setAttribute('aria-hidden', 'false');
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'ゲームオーバー\nScore: ' + score + '\n評価: ' + evaluateScore(score);

    // play hit/explode sound for game over
    initAudioIfNeeded().then(()=>{
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      playHitSound();
    }).catch(()=>{ playHitSound(); });

    // stop BGM
    pauseBgm();

    ignoreInputUntil = performance.now() + 1000;
  }

  function reset() {
    ship = { x: 80, y: canvas.clientHeight/2 - 10, vy: 0, r: 22, angle: 0, thrusting: false };
    pipes = [];
    playerBullets.length = 0;
    enemyBullets.length = 0;
    enemy = null;
    enemyActive = false;
    enemySpawnedForScore5 = false;
    score = 0;
    scoreEl.textContent = 'Score: 0';
    running = false;
    gameOver = false;
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'タップしてスタート';
    startTime = null;
    lastPipeTime = performance.now();
    nextPipeDelay = INITIAL_INTERVAL_MAX;
    gameOverPanel.style.display = 'none';
    gameOverPanel.setAttribute('aria-hidden', 'true');

    // 念のため BGM を停止して先頭に戻す
    pauseBgm();
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function start() {
    running = true;
    gameOver = false;
    messageEl.style.display = 'none';
    messageEl.textContent = '';
    startTime = performance.now();
    lastPipeTime = performance.now();
    if (pipes.length === 0) spawnPipe();

    // ゲーム開始時に BGM を最初から再生
    initAudioIfNeeded().then(()=>{
      // resume AudioContext if needed
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      playBgm();
    }).catch(()=>{ playBgm(); });
  }

  // 初期化
  reset();
  requestAnimationFrame(loop);

  // キーボードジャンプ（デバッグ）
  window.addEventListener('keydown', e => { if (e.code === 'Space') onPointerDown(e); });

  // ページ非表示時に BGM を自動で一時停止（安全処理）
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      pauseBgm();
    } else {
      if (running) {
        // 再開時は最初から再生（仕様に合わせる）
        playBgm();
      }
    }
  });

})();
</script>
</body>
</html>