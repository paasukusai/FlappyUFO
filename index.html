<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>宇宙風パイプ＋元の主人公（ジャンプ音付き）</title>
<style>
  html,body { height:100%; margin:0; background:#021022; -webkit-tap-highlight-color: transparent; }
  canvas#game {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    background: linear-gradient(#071428,#0b2a44);
  }
  .overlay { position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
  #score { position:absolute; left:12px; top:12px; z-index:30; font-size:20px; color:#fff; text-shadow:0 2px 6px rgba(0,0,0,0.6); pointer-events:auto; background: rgba(255,255,255,0.06); padding:6px 10px; border-radius:8px; }
  .center { position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); text-align:center; z-index:30; pointer-events:auto; }
  #message { font-size:18px; color:#fff; text-shadow:0 2px 4px rgba(0,0,0,0.5); background: rgba(0,0,0,0.18); display:inline-block; padding:8px 12px; border-radius:8px; white-space:pre-line; }
  #gameOverPanel { position: absolute; left: 50%; top: 36%; transform: translate(-50%, -50%); z-index: 40; pointer-events: none; text-align: center; color: #fff; display: none; }
  #finalScore { font-size: 48px; font-weight: 700; color: #ffd86b; text-shadow: 0 6px 18px rgba(0,0,0,0.6); margin-bottom: 8px; }
  #finalEval { font-size: 22px; color: #bfefff; margin-bottom: 6px; }
  #retryHint { font-size: 14px; color: rgba(255,255,255,0.85); }
  @media (max-width:420px){
    #message{ font-size:16px; padding:6px 10px; }
    #finalScore{ font-size:36px; }
    #finalEval{ font-size:18px; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="overlay" aria-hidden="false">
  <div id="score">Score: 0</div>
  <div class="center" id="centerMessage"><div id="message">タップしてスタート</div></div>
</div>

<div id="gameOverPanel" aria-hidden="true">
  <div id="finalScore">0</div>
  <div id="finalEval">評価</div>
  <div id="retryHint">1秒後にタップで再開できます</div>
</div>

<script>
(() => {
  const JUMP_SOUND_SRC = 'assets/jump.wav'; // ← ここを実際のパスに変更してください

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const gameOverPanel = document.getElementById('gameOverPanel');
  const finalScoreEl = document.getElementById('finalScore');
  const finalEvalEl = document.getElementById('finalEval');

  // Audio 初期化（ユーザー操作で AudioContext を作るための安全処理）
  let audioCtx = null;
  let jumpAudio = null;
  let jumpBuffer = null;
  let jumpGain = null;
  let audioInitialized = false;

  async function initAudioIfNeeded() {
    if (audioInitialized) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      jumpGain = audioCtx.createGain();
      jumpGain.gain.value = 0.9;
      jumpGain.connect(audioCtx.destination);

      // fetch the wav file and decode
      const resp = await fetch(JUMP_SOUND_SRC, {cache: "no-store"});
      if (!resp.ok) throw new Error('audio fetch failed');
      const ab = await resp.arrayBuffer();
      jumpBuffer = await audioCtx.decodeAudioData(ab);
      audioInitialized = true;
    } catch (err) {
      // 音声が読み込めない場合は静かに無効化（再生は行わない）
      console.warn('Audio init failed:', err);
      audioInitialized = false;
    }
  }

  function playJumpSound() {
    // 再生は AudioContext が初期化されている場合のみ
    if (!audioInitialized || !jumpBuffer || !audioCtx) return;
    try {
      const src = audioCtx.createBufferSource();
      src.buffer = jumpBuffer;
      src.connect(jumpGain);
      src.start();
    } catch (e) {
      // 再生失敗は無視
      console.warn('jump play failed', e);
    }
  }

  function resize() {
    const ratio = window.devicePixelRatio || 1;
    const w = Math.max(window.innerWidth, 320);
    const h = Math.max(window.innerHeight, 320);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * ratio);
    canvas.height = Math.floor(h * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- game constants ---
  const INITIAL_GAP = 300;
  const MIN_GAP = 80;
  const SCORE_RAMP_MAX = 100;
  const RAMP_DURATION_MS = 30000;
  const INITIAL_INTERVAL_MAX = 2600;
  const MIN_INTERVAL = 1800;
  const INTERVAL_RAMP_MS = 30000;
  const GRAVITY = 0.6;
  const THRUST = -10;
  const PIPE_WIDTH = 52;
  const PIPE_SPEED_BASE = 2.2;
  const PIPE_STRIPES = 3;
  const SPARK_CHANCE = 0.006;

  const COLOR_HUES = [200,160,280,40,10,120,260,340,30,195];

  // --- state ---
  let ship = { x: 80, y: 150, vy: 0, r: 22, angle: 0, thrusting: false };
  let pipes = [];
  let lastPipeTime = 0;
  let nextPipeDelay = INITIAL_INTERVAL_MAX;
  let score = 0;
  let running = false;
  let gameOver = false;
  let lastTime = 0;
  let startTime = null;
  let ignoreInputUntil = 0;

  // --- background assets / particles ---
  const starLayers = [
    {count: 80, speed: 0.02, sizeRange: [0.6,1.6], color: '#e8f8ff', offset: Math.random()*1000},
    {count: 40, speed: 0.06, sizeRange: [1.2,2.6], color: '#cfefff', offset: Math.random()*1000},
    {count: 18, speed: 0.12, sizeRange: [1.8,3.6], color: '#ffffff', offset: Math.random()*1000}
  ];
  const stars = [];
  for (let li=0; li<starLayers.length; li++){
    const layer = starLayers[li];
    for (let i=0;i<layer.count;i++){
      stars.push({
        layer: li,
        x: Math.random(),
        y: Math.random(),
        size: layer.sizeRange[0] + Math.random()*(layer.sizeRange[1]-layer.sizeRange[0]),
        tw: Math.random()*1000
      });
    }
  }

  const nebulaLayers = [
    {colorA: '#0b2a44', colorB: '#1b4a66', alpha: 0.12, speed: 0.02, scale: 1.6, offset: Math.random()*1000},
    {colorA: '#122b3f', colorB: '#0f3a5a', alpha: 0.08, speed: 0.035, scale: 1.1, offset: Math.random()*1000},
    {colorA: '#0f2b44', colorB: '#072a3a', alpha: 0.06, speed: 0.06, scale: 0.8, offset: Math.random()*1000}
  ];

  const meteors = [];
  for (let i=0;i<12;i++){
    meteors.push({
      x: Math.random(), y: Math.random(), vx: -0.002 - Math.random()*0.006, vy: 0.001 + Math.random()*0.003,
      life: Math.random()*4000, t: Math.random()*6000, size: 1 + Math.random()*2
    });
  }

  function createNoiseCanvas(w,h,alpha){
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const g = c.getContext('2d');
    const img = g.createImageData(w,h);
    for (let i=0;i<img.data.length;i+=4){
      const v = 200 + Math.floor(Math.random()*55);
      img.data[i]=v; img.data[i+1]=v; img.data[i+2]=v; img.data[i+3]=Math.floor(255*alpha*Math.random());
    }
    g.putImageData(img,0,0);
    return c;
  }
  const noise = createNoiseCanvas(128,128,0.04);

  // --- helpers ---
  function difficultyFactor(){ if(!startTime) return 0; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/RAMP_DURATION_MS); return t*t; }
  function currentIntervalMax(){ if(!startTime) return INITIAL_INTERVAL_MAX; const now=performance.now(); const elapsed=Math.max(0, now-startTime); const t=Math.min(1, elapsed/INTERVAL_RAMP_MS); const f=t*t; return Math.round(INITIAL_INTERVAL_MAX + (MIN_INTERVAL - INITIAL_INTERVAL_MAX)*f); }
  function currentPipeSpeed(){ const f=difficultyFactor(); return PIPE_SPEED_BASE + (3.0 - PIPE_SPEED_BASE)*f; }

  function gapAtSpawn() {
    const sf = Math.min(1, score / SCORE_RAMP_MAX);
    const gap = Math.round(INITIAL_GAP + (MIN_GAP - INITIAL_GAP) * sf);
    return gap;
  }

  function onPointerDown(e){
    if (e.cancelable) e.preventDefault();
    // 初回ユーザー操作で AudioContext を初期化して音声を読み込む
    initAudioIfNeeded().catch(()=>{ /* 無視 */ });

    if (performance.now() < ignoreInputUntil) return;
    if (gameOver) { reset(); start(); return; }
    if (!running) { start(); return; }

    // ジャンプ処理
    ship.vy = THRUST;
    ship.thrusting = true;
    ship.angle = -0.5;

    // ジャンプ音を再生
    playJumpSound();
  }
  function onPointerUp(e){ if (e.cancelable) e.preventDefault(); ship.thrusting = false; }
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointerup', onPointerUp, {passive:false});
  canvas.addEventListener('pointercancel', onPointerUp, {passive:false});
  document.body.addEventListener('pointerdown', onPointerDown, {passive:false});
  document.body.addEventListener('pointerup', onPointerUp, {passive:false});

  function spawnPipe(){
    const ch = canvas.clientHeight;
    const gap = gapAtSpawn();
    const minTop = 40;
    const maxTop = ch - gap - 40;
    const top = Math.floor(Math.random() * Math.max(1, (maxTop - minTop + 1))) + minTop;

    const bucket = Math.floor(score / 10);
    const hue = COLOR_HUES[bucket % COLOR_HUES.length];

    pipes.push({ x: canvas.clientWidth + 10, top: top, gap: gap, hue: hue, passed: false, sparkleTimer: 0 });

    const intervalMax = currentIntervalMax();
    const range = Math.max(0, intervalMax - MIN_INTERVAL);
    nextPipeDelay = MIN_INTERVAL + Math.floor(Math.random() * (range + 1));
    lastPipeTime = performance.now();
  }

  function circleRectIntersect(cx, cy, r, rx, ry, rw, rh){ const nearestX = Math.max(rx, Math.min(cx, rx + rw)); const nearestY = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - nearestX; const dy = cy - nearestY; return (dx*dx + dy*dy) < (r*r); }
  function hslToRgb(h,s,l){ s/=100; l/=100; const k = n => (n + h/30) % 12; const a = s * Math.min(l,1-l); const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); return [Math.round(255*f(0)), Math.round(255*f(8)), Math.round(255*f(4))]; }

  // --- background & drawing (unchanged from previous) ---
  function drawBackground() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#041426');
    g.addColorStop(0.5, '#071428');
    g.addColorStop(1, '#081a2a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const now = performance.now();

    for (let i=0;i<nebulaLayers.length;i++){
      const nl = nebulaLayers[i];
      const t = (now * nl.speed + nl.offset) % (w*2);
      ctx.save();
      ctx.globalAlpha = nl.alpha;
      const cx = (Math.sin(now*0.00012 + nl.offset*0.001) * 0.5 + 0.5) * w;
      const cy = (Math.cos(now*0.00009 + nl.offset*0.001) * 0.25 + 0.35) * h;
      const rx = w * nl.scale;
      const ry = h * nl.scale * 0.45;
      const rg = ctx.createRadialGradient(cx, cy, Math.min(40, rx*0.06), cx, cy, rx);
      rg.addColorStop(0, nl.colorB);
      rg.addColorStop(0.5, nl.colorA);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.ellipse(cx + (t % (w*1.2)) - w*0.6, cy, rx, ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    for (let s of stars) {
      const layer = starLayers[s.layer];
      const sx = (s.x * w - (now * layer.speed * (s.layer+1) * 0.6) - layer.offset + w*10) % w;
      const sy = (s.y * h + Math.sin((now + s.tw) / (800 + s.layer*120)) * 6 * (s.layer+0.2)) % h;

      let occluded = false;
      for (let p of pipes) {
        const px = p.x;
        const pw = PIPE_WIDTH;
        if (sx >= px && sx <= px + pw && sy >= 0 && sy <= p.top) { occluded = true; break; }
        if (sx >= px && sx <= px + pw && sy >= p.top + p.gap && sy <= h) { occluded = true; break; }
      }
      if (occluded) continue;

      ctx.globalAlpha = 0.7 - s.layer*0.18;
      ctx.fillStyle = layer.color;
      const size = s.size * (1 + 0.2 * Math.sin((now + s.tw)/600));
      ctx.fillRect(sx, sy, size, size);
    }
    ctx.globalAlpha = 1;

    for (let m of meteors) {
      m.t += 16;
      if (m.t > m.life + 2000) {
        if (Math.random() < 0.02) {
          m.x = 1.1 + Math.random()*0.6;
          m.y = Math.random()*0.4;
          m.vx = -0.002 - Math.random()*0.006;
          m.vy = 0.001 + Math.random()*0.003;
          m.life = 800 + Math.random()*2200;
          m.t = 0;
          m.size = 1 + Math.random()*2;
        }
      } else if (m.t < m.life) {
        const mx = (m.x + m.vx * (m.t/1000)) * w;
        const my = (m.y + m.vy * (m.t/1000)) * h;
        ctx.save();
        ctx.globalAlpha = 0.9 * (1 - m.t / m.life);
        ctx.strokeStyle = 'rgba(255,255,220,0.9)';
        ctx.lineWidth = Math.max(1, m.size);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx - m.vx*80*w, my - m.vy*80*h);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.drawImage(noise, 0, 0, w, h);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#000';
    for (let y=0; y<h; y+=2) ctx.fillRect(0, y, w, 1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const vg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.1, w/2, h/2, Math.max(w,h)*0.9);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.28)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function drawSpacePipe(p) {
    const x = p.x;
    const w = PIPE_WIDTH;
    const h = canvas.clientHeight;
    const top = p.top;
    const gap = p.gap;
    const hue = p.hue;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `rgba(${hslToRgb(hue, 60, 50).join(',')}, 0.28)`;
    if (x - 8 < canvas.clientWidth) {
      ctx.fillRect(x - 8, 0, 8, top);
      ctx.fillRect(x - 8, top + gap, 8, h - (top + gap));
      ctx.fillRect(x + w, 0, 8, top);
      ctx.fillRect(x + w, top + gap, 8, h - (top + gap));
    }
    ctx.restore();

    const gradTop = ctx.createLinearGradient(x, 0, x + w, 0);
    gradTop.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradTop.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradTop.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradTop;
    ctx.fillRect(x, 0, w, top);

    const gradBottom = ctx.createLinearGradient(x, 0, x + w, 0);
    gradBottom.addColorStop(0, `hsl(${hue} 60% 28%)`);
    gradBottom.addColorStop(0.5, `hsl(${hue} 60% 45%)`);
    gradBottom.addColorStop(1, `hsl(${hue} 60% 22%)`);
    ctx.fillStyle = gradBottom;
    ctx.fillRect(x, top + gap, w, h - (top + gap));

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${hue} 60% 80%)`;
    ctx.lineWidth = 1;
    for (let i = 0; i < PIPE_STRIPES; i++) {
      const sx = x + (i + 1) * (w / (PIPE_STRIPES + 1));
      ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, top); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sx, top + gap); ctx.lineTo(sx, h); ctx.stroke();
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.9;
    const edgeGrad = ctx.createLinearGradient(x, 0, x + w, 0);
    edgeGrad.addColorStop(0, 'rgba(255,255,255,0.18)');
    edgeGrad.addColorStop(0.5, 'rgba(255,255,255,0.06)');
    edgeGrad.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(x + 2, 0, 4, top);
    ctx.fillRect(x + 2, top + gap, 4, h - (top + gap));
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(x + w - 6, 0, 6, top);
    ctx.fillRect(x + w - 6, top + gap, 6, h - (top + gap));
    ctx.restore();

    if (Math.random() < SPARK_CHANCE) {
      p.sparkleTimer = 200 + Math.random() * 300;
      p.sparkX = x + Math.random() * w;
      p.sparkY = (Math.random() < 0.5) ? (Math.random() * top) : (top + gap + Math.random() * (h - (top + gap)));
    }
    if (p.sparkleTimer > 0) {
      const t = p.sparkleTimer;
      const a = Math.min(1, t / 120);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = 'rgba(255,255,220,0.95)';
      ctx.beginPath();
      ctx.arc(p.sparkX, p.sparkY, 2 + Math.random()*1.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      p.sparkleTimer -= 16;
    }

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${(hue + 40) % 360} 70% 60%)`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.ellipse(x + w - 6, Math.max(12, top - 8), 8, 3, Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x + w - 6, top + gap + 8, 8, 3, -Math.PI * 0.2, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawShipOriginal(cx, cy, r, angle, thrusting) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    const grad = ctx.createLinearGradient(-r, -r, r, r);
    grad.addColorStop(0, '#cfd8dc');
    grad.addColorStop(1, '#9aa6ad');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r*0.85, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#2ec4ff';
    ctx.beginPath();
    ctx.ellipse(r*0.18, -r*0.12, r*0.36, r*0.26, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(r*0.28, -r*0.22, r*0.12, r*0.08, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#b0bec5';
    ctx.beginPath();
    ctx.moveTo(-r*0.9, -r*0.15);
    ctx.lineTo(-r*1.4, -r*0.45);
    ctx.lineTo(-r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(r*0.9, -r*0.15);
    ctx.lineTo(r*1.4, -r*0.45);
    ctx.lineTo(r*1.1, r*0.25);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#7b8a8f';
    ctx.beginPath();
    ctx.ellipse(0, r*0.6, r*0.35, r*0.18, 0, 0, Math.PI*2);
    ctx.fill();

    if (thrusting) {
      const t = performance.now() / 60;
      for (let i = 0; i < 3; i++) {
        const fx = (Math.sin(t + i) * r * 0.06);
        const fy = r*0.9 + Math.abs(Math.sin(t*1.5 + i))*r*0.25;
        ctx.fillStyle = i===0 ? 'rgba(255,180,60,0.95)' : (i===1 ? 'rgba(255,120,40,0.85)' : 'rgba(255,80,20,0.7)');
        ctx.beginPath();
        ctx.ellipse(fx, fy, r*0.18 - i*0.04, r*0.28 - i*0.06, Math.PI*0.1*i, 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      ctx.fillStyle = 'rgba(255,140,60,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, r*0.95, r*0.12, r*0.06, 0, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function draw() {
    drawBackground();
    for (let p of pipes) drawSpacePipe(p);
    ship.x = Math.max(ship.r + 8, Math.min(ship.x, canvas.clientWidth - ship.r - 8));
    drawShipOriginal(ship.x, ship.y, ship.r, ship.angle, ship.thrusting);
  }

  function update(dt) {
    if (!running) return;
    ship.vy += GRAVITY;
    ship.y += ship.vy;
    const targetAngle = ship.vy < 0 ? -0.5 : Math.min(1.0, ship.vy / 12);
    ship.angle += (targetAngle - ship.angle) * 0.08;

    const speed = currentPipeSpeed();
    for (let p of pipes) {
      p.x -= speed;
      if (!p.passed && p.x + PIPE_WIDTH < ship.x - ship.r) {
        p.passed = true;
        score++;
        scoreEl.textContent = 'Score: ' + score;
      }
    }
    pipes = pipes.filter(p => p.x + PIPE_WIDTH > -40);

    const groundY = canvas.clientHeight;
    if (ship.y + ship.r > groundY || ship.y - ship.r < 0) {
      endGame();
    }

    for (let p of pipes) {
      const topRect = { x: p.x, y: 0, w: PIPE_WIDTH, h: p.top };
      const bottomRect = { x: p.x, y: p.top + p.gap, w: PIPE_WIDTH, h: canvas.clientHeight - (p.top + p.gap) };
      if (circleRectIntersect(ship.x, ship.y, ship.r, topRect.x, topRect.y, topRect.w, topRect.h) ||
          circleRectIntersect(ship.x, ship.y, ship.r, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)) {
        endGame();
      }
    }

    if (performance.now() - lastPipeTime > nextPipeDelay) {
      spawnPipe();
    }
  }

  function evaluateScore(s) {
    if (s >= 60) return '伝説のUFO操縦士';
    if (s >= 30) return '熟練UFO操縦士';
    if (s >= 10) return '見習いUFO操縦士';
    return '初心者UFO操縦士';
  }

  function endGame() {
    running = false;
    gameOver = true;
    ship.thrusting = false;
    finalScoreEl.textContent = score;
    finalEvalEl.textContent = evaluateScore(score);
    gameOverPanel.style.display = 'block';
    gameOverPanel.setAttribute('aria-hidden', 'false');
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'ゲームオーバー\nScore: ' + score + '\n評価: ' + evaluateScore(score);
    ignoreInputUntil = performance.now() + 1000;
  }

  function reset() {
    ship = { x: 80, y: canvas.clientHeight/2 - 10, vy: 0, r: 22, angle: 0, thrusting: false };
    pipes = [];
    score = 0;
    scoreEl.textContent = 'Score: 0';
    running = false;
    gameOver = false;
    messageEl.style.display = 'inline-block';
    messageEl.textContent = 'タップしてスタート';
    startTime = null;
    lastPipeTime = performance.now();
    nextPipeDelay = INITIAL_INTERVAL_MAX;
    gameOverPanel.style.display = 'none';
    gameOverPanel.setAttribute('aria-hidden', 'true');
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function start() {
    running = true;
    gameOver = false;
    messageEl.style.display = 'none';
    messageEl.textContent = '';
    startTime = performance.now();
    lastPipeTime = performance.now();
    if (pipes.length === 0) spawnPipe();
  }

  // 初期化
  reset();
  requestAnimationFrame(loop);

  // キーボードジャンプ（デバッグ）
  window.addEventListener('keydown', e => { if (e.code === 'Space') onPointerDown(e); });

})();
</script>
</body>
</html>